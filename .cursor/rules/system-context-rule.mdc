---
description: System context and rule synchronization for LLM Chat Application project
globs: []
alwaysApply: true
---

# Project Context and Architecture

## SYSTEM_CONTEXT

You are a senior Silicon Valley engineer working on a **Next.js 15 + React 19 + TypeScript** project following the **Silicon Valley DDD Frontend Architecture** pattern.

### Required Rule Understanding on Startup:
- `.cursor/rules/general-rule.mdc`: Git conventions, commit standards, and core development principles
- `.cursor/rules/naming-convention-rule.mdc`: Universal naming conventions across all file types
- `.cursor/rules/frontend-standard-rule.mdc`: Frontend orchestrator and structured analysis process
- `.cursor/rules/frontend/`: Domain-specific rules for specialized patterns

### Architecture Pattern: **"Silicon Valley DDD Frontend"**

This project follows the **Silicon Valley Domain-Driven Design (DDD) Frontend Architecture**, which emphasizes:
- **Single Source of Truth** for types and state
- **Hierarchical Component Organization** (primitives â†’ layout â†’ features)
- **Legacy Compatibility Layers** with clear migration paths
- **Pure Function Utilities** separated from business logic
- **Modern React/Next.js Patterns** (Server Components First)

#### **Current Project Structure:**
```
{PROJECT_ROOT}/
â”œâ”€â”€ .cursor/rules/               # Project-wide Cursor rules
â”‚   â”œâ”€â”€ frontend/               # Domain-specific frontend rules
â”‚   â”œâ”€â”€ general-rule.mdc        # Git conventions and core principles
â”‚   â”œâ”€â”€ frontend-standard-rule.mdc # Frontend orchestrator
â”‚   â”œâ”€â”€ naming-convention-rule.mdc # Universal naming standards
â”‚   â””â”€â”€ system-context-rule.mdc # System awareness and rule sync
â”œâ”€â”€ {BACKEND_DIR}/              # Backend application (FastAPI/Express/etc)
â”œâ”€â”€ {FRONTEND_DIR}/             # Next.js 15+ frontend application
â”‚   â”œâ”€â”€ src/                   # Source code (Domain-Driven Design)
â”‚   â”‚   â”œâ”€â”€ app/               # App Router (Next.js 15+)
â”‚   â”‚   â”‚   â”œâ”€â”€ layout.tsx     # Root layout with global providers
â”‚   â”‚   â”‚   â”œâ”€â”€ page.tsx       # Home page (Server Component)
â”‚   â”‚   â”‚   â””â”€â”€ globals.css    # Global styles and Tailwind
â”‚   â”‚   â”œâ”€â”€ types/             # Global Types Hub (Single Source of Truth)
â”‚   â”‚   â”‚   â””â”€â”€ index.ts       # All shared TypeScript interfaces/types
â”‚   â”‚   â”œâ”€â”€ lib/               # ğŸ”§ Pure Utilities & Infrastructure
â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts       # Barrel exports for utilities
â”‚   â”‚   â”‚   â”œâ”€â”€ utils.ts       # Framework utility functions (Tailwind/etc)
â”‚   â”‚   â”‚   â””â”€â”€ validation.ts  # Zod schemas and validation logic
â”‚   â”‚   â”œâ”€â”€ store/             # ğŸª Global State Management (Zustand/Redux)
â”‚   â”‚   â”‚   â”œâ”€â”€ {domain}-store.ts  # Domain state with persistence
â”‚   â”‚   â”‚   â””â”€â”€ store.types.ts # Store-specific type definitions
â”‚   â”‚   â”œâ”€â”€ components/        # UI Components (Hierarchical)
â”‚   â”‚   â”‚   â”œâ”€â”€ ui/           # Design system primitives (shadcn/ui)
â”‚   â”‚   â”‚   â”œâ”€â”€ layout/       # Layout components (Server First)
â”‚   â”‚   â”‚   â””â”€â”€ features/     # Feature-specific components
â”‚   â”‚   â”œâ”€â”€ features/          # ğŸ“ Domain Features (Legacy Compatibility)
â”‚   â”‚   â”‚   â””â”€â”€ {domain}/     # Feature domain
â”‚   â”‚   â”‚       â”œâ”€â”€ types/    # Feature-specific types (deprecated)
â”‚   â”‚   â”‚       â”œâ”€â”€ client/   # Client components
â”‚   â”‚   â”‚       â”œâ”€â”€ server/   # Server components
â”‚   â”‚   â”‚       â””â”€â”€ index.ts  # Barrel exports for backward compatibility
â”‚   â”‚   â””â”€â”€ styles/           # Styling (if needed beyond Tailwind)
â”‚   â”œâ”€â”€ public/               # Static assets
â”‚   â”œâ”€â”€ next.config.ts        # Next.js configuration
â”‚   â”œâ”€â”€ package.json          # Frontend dependencies
â”‚   â”œâ”€â”€ tsconfig.json         # TypeScript strict configuration
â”‚   â”œâ”€â”€ biome.json           # Biome formatting/linting config
â”‚   â”œâ”€â”€ components.json       # shadcn/ui configuration
â”‚   â””â”€â”€ tailwind.config.ts    # Tailwind CSS configuration
â”œâ”€â”€ .github/                  # CI/CD automation
â”œâ”€â”€ docs/                     # Project documentation
â”œâ”€â”€ package.json             # Root workspace configuration
â”œâ”€â”€ pnpm-workspace.yaml      # Monorepo workspace setup
â””â”€â”€ README.md                # Project documentation
```

### **Silicon Valley DDD Architecture Principles:**

#### **1. Domain-Driven Design (DDD) Layers**
- **`@/types`** ğŸ›ï¸: Global types hub - single source of truth for all TypeScript interfaces
- **`@/lib`** ğŸ”§: Pure utilities, validation logic, and infrastructure concerns
- **`@/store`** ğŸª: Centralized state management (Zustand/Redux/Context)
- **`@/components`** ğŸ§©: Hierarchical UI organization (primitives â†’ layout â†’ features)
- **`@/features`** ğŸ“: Legacy compatibility layer with clear migration paths

#### **2. Import Path Strategy (Universal Pattern)**
```typescript
// âœ… ALWAYS: Global types and utilities (single source of truth)
import type { EntityType, ApiResponse } from '@/types';
import { cn, validateInput } from '@/lib';

// âœ… PREFERRED: Direct component imports (avoid circular dependencies)
import { MainLayout } from '@/components/layout/main-layout';
import { FeatureComponent } from '@/components/features/feature-component';

// âœ… ACCEPTABLE: Feature barrel imports (external to feature only)
import { FeatureShell } from '@/features/feature-name';

// âŒ DEPRECATED: Feature-specific types (migrate to @/types)
import type { LegacyType } from '@/features/*/types'; // Use @/types instead
```

#### **3. Type Architecture (Anti-Duplication Pattern)**
- **Global Hub**: `@/types/index.ts` contains ALL shared interfaces
- **Store Types**: `@/store/store.types.ts` for state management-specific types
- **Legacy Types**: `@/features/*/types/*` with deprecation notices and re-exports to @/types
- **Zero Duplication**: Single source of truth with strategic re-exports for backward compatibility

#### **4. Component Hierarchy (Design System Pattern)**
- **Design System**: Primitives (`@/components/ui`) - reusable atomic components
- **Layout**: Structure (`@/components/layout`) - Server Components for page structure
- **Features**: Domain logic (`@/components/features`) - business-specific components
- **Legacy**: Compatibility (`@/features/*/client|server`) - backward compatibility layer

#### **5. State Management Architecture (Modern React Pattern)**
- **Global State**: Centralized store with persistence (`@/store/{domain}-store.ts`)
- **React 19 Integration**: `useActionState`, `useOptimistic` for form handling
- **Server-First**: Default to Server Components, minimal client state
- **URL State**: Stateful URLs for shareable application state (`@nuqs` or similar)

#### **6. Migration Strategy (Legacy Compatibility)**
- **Phase 1**: Create new structure alongside legacy
- **Phase 2**: Add deprecation notices and re-exports
- **Phase 3**: Migrate consumers to new imports
- **Phase 4**: Remove legacy structure completely

### **Adapting This Pattern to Other Projects:**

To use this **Silicon Valley DDD Frontend Architecture** in other projects:

1. **Replace Placeholders**: Update `{PROJECT_ROOT}`, `{FRONTEND_DIR}`, `{BACKEND_DIR}`, `{domain}` with actual names
2. **Technology Stack**: Adapt for your stack (Vue.js, Angular, React Native, etc.)
3. **State Management**: Choose appropriate solution (Zustand, Redux, Pinia, etc.)
4. **Design System**: Replace shadcn/ui references with your component library
5. **Domain Names**: Replace example domains (`chats`, etc.) with your business domains
6. **Rule References**: Update rule references to match your project's Cursor rules structure

#### **Technology Stack Variations:**
- **React**: Next.js 15+, Remix, Vite + React Router
- **Vue**: Nuxt 3+, Vue 3 + Vite
- **Angular**: Angular 17+ with standalone components
- **Mobile**: React Native, Expo, Flutter (adapt folder structure)
- **State**: Zustand, Redux Toolkit, Pinia, Context API, Jotai
- **Styling**: Tailwind, Styled Components, CSS Modules, Sass

## Rule Hierarchy Understanding

Before making any changes, understand this rule structure:

### **1. Foundation Layer (Universal)**
- **`general-rule.mdc`** â†’ Git conventions, commit standards, workflow guidelines
- **`naming-convention-rule.mdc`** â†’ Universal naming (kebab-case files, PascalCase components)

### **2. Frontend Orchestrator Layer**
- **`frontend-standard-rule.mdc`** â†’ Core orchestrator with Analysis Process and domain rule references

### **3. Domain-Specific Layer**
- **`typescript-rule.mdc`** â†’ Type safety, Zod validation, pure function patterns
- **`react19-core-rule.mdc`** â†’ Actions, useActionState, useOptimistic, use() API
- **`nextjs15-core-rule.mdc`** â†’ Async Request APIs, Turbopack, after() API
- **`component-patterns-rule.mdc`** â†’ Component architecture orchestration and integration patterns
- **`ui-styling-patterns-rule.mdc`** â†’ shadcn/ui integration, responsive design, and accessibility
- **`rsc-component-patterns-rule.mdc`** â†’ RSC patterns, error boundaries, and custom hooks
- **`rsc-performance-rule.mdc`** â†’ Server-side optimization and caching strategies
- **`client-performance-rule.mdc`** â†’ Core Web Vitals, bundle optimization, image optimization
- **`animation-patterns-rule.mdc`** â†’ Motion/React animation with Tailwind separation

## File Management Rules

### ON_FILE_CHANGE
Required actions after any code changes:

1. **VERIFY rule compliance** against the appropriate domain rule:
   - TypeScript files â†’ Check `typescript-rule.mdc` standards
   - React components â†’ Validate against `component-patterns-rule.mdc` (orchestrator)
   - UI/Styling â†’ Reference `ui-styling-patterns-rule.mdc` for shadcn/ui and responsive design
   - Server Components â†’ Follow `rsc-component-patterns-rule.mdc` for RSC patterns
   - Performance-critical code â†’ Reference `rsc-performance-rule.mdc` or `client-performance-rule.mdc`
   - Animations â†’ Follow `animation-patterns-rule.mdc` guidelines

2. **APPLY structured reasoning** from `frontend-standard-rule.mdc`:
   - Request Analysis â†’ Understand the task type and requirements
   - Solution Planning â†’ Break down into logical steps
   - Implementation Strategy â†’ Choose appropriate patterns and consider implications

3. **FOLLOW naming conventions** from `naming-convention-rule.mdc`:
   - Files: kebab-case (`user-profile.tsx`)
   - Components: PascalCase (`UserProfile`)
   - Functions: camelCase with verb-first (`handleSubmit`, `validateForm`)

4. **COMMIT properly** using `general-rule.mdc` standards:
   - Conventional Commits format: `type(scope): description`
   - Single feature per commit
   - Well-documented, self-explanatory code

## Technology Stack Alignment

### Core Technologies (Enforce Consistency)
- **Frontend**: Next.js 15 + React 19 + TypeScript 5 + Tailwind CSS
- **UI Components**: shadcn/ui + Radix + Lucide icons
- **Animation**: Motion library (motion/react)
- **Linting**: Biome (formatting) + ESLint 9 (React-specific rules)
- **Package Manager**: pnpm
- **Backend**: FastAPI + Python
- **Deployment**: Vercel

### Development Standards (Always Enforce)
- **Server Components First**: Default to RSC, minimize `'use client'`
- **Performance Targets**: Lighthouse 90+ Performance, 95+ Accessibility
- **Type Safety**: TypeScript strict mode, no `any` types
- **React 19 Patterns**: useActionState, useOptimistic, Server Actions
- **Bootcamp Requirements**: Visual contrast, pleasant UX, Vercel deployment

## Context Switching Protocol

### When Working on Different Areas:
1. **Frontend Components** â†’ Reference `frontend-standard-rule.mdc` + `component-patterns-rule.mdc` (orchestrator)
2. **UI/Styling Work** â†’ Primary: `ui-styling-patterns-rule.mdc`, Secondary: `frontend-standard-rule.mdc`
3. **Server Components** â†’ Primary: `rsc-component-patterns-rule.mdc`, Secondary: `rsc-performance-rule.mdc`
4. **TypeScript/Validation** â†’ Primary: `typescript-rule.mdc`, Secondary: domain rules
5. **Performance Issues** â†’ `rsc-performance-rule.mdc` OR `client-performance-rule.mdc` based on context
6. **Animations** â†’ `animation-patterns-rule.mdc` + performance considerations
7. **Git/Workflow** â†’ `general-rule.mdc` for commit and branch standards

### Rule Precedence:
1. **Project Requirements** (in `frontend-standard-rule.mdc`) â†’ Highest priority
2. **General Rules** (Git, naming) â†’ Universal application
3. **Domain Rules** â†’ Context-specific application
4. **Performance Rules** â†’ Critical for production readiness

## AI Collaboration Context

This project integrates with:
- **Cursor AI** (Code generation) â†’ Follow all rule patterns
- **CodeRabbit** (Code review) â†’ R
- **QODO AI** (Testing) â†’ Create pure, testable functions

### Code Generation Guidelines:
- Generate enterprise-grade, production-ready code
- Follow Silicon Valley engineering standards
- Apply structured reasoning process
- Ensure all patterns align with the comprehensive rule system
- Maintain consistency across the entire codebase

This context ensures Cursor AI maintains awareness of the complete rule ecosystem and generates code that aligns with all established standards.
